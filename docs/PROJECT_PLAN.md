# Prism Protocol: Project Plan & Checklist

## 1. Core Project Goal

To enable efficient, scalable, and verifiable token distribution on Solana, minimizing write contention and optimizing on-chain resources. (See `README.md` for full details).

## 2. Core Components - Implementation Checklist

### On-Chain Program (`programs/prism-protocol/src/`)

- **State Accounts (`state.rs`):**
  - [x] `CampaignV0` struct defined ✅
  - [x] `CohortV0` struct defined ✅
  - [x] `ClaimReceiptV0` struct defined ✅
  - [ ] Future enhanced cohort versions (e.g., with optimizations) - _Future Design_
- **Instructions (`instructions/` & `lib.rs`):**
  - [x] `handle_initialize_campaign_v0` ✅
  - [x] `handle_initialize_cohort_v0` ✅
  - [x] `handle_claim_tokens_v0` ✅
  - [x] `handle_set_campaign_active_status` ✅
  - [x] `handle_reclaim_tokens` ✅
  - [ ] Future enhanced instruction versions - _Future Design_
- **Merkle Logic:**
  - [x] `ClaimLeaf` struct and `hash_claim_leaf` function (`merkle_leaf.rs`) ✅
  - [x] `verify_merkle_proof` function (in `claim_tokens_v0.rs`) ✅
  - [x] Domain separation with 0x00/0x01 prefixes for security ✅
- **Program Entrypoint (`lib.rs`):**
  - [x] Declare program ID ✅
  - [x] Define `initialize_campaign_v0` public instruction ✅
  - [x] Define `initialize_cohort_v0` public instruction ✅
  - [x] Define `claim_tokens_v0` public instruction ✅
  - [x] Define `set_campaign_active_status` public instruction ✅
  - [x] Define `reclaim_tokens` public instruction ✅

### Crate Structure (Completed Refactoring)

- **Core Program (`prism-protocol`):**
  - [x] Minimal on-chain program with core functionality ✅
  - [x] Clean separation from off-chain utilities ✅
- **SDK Crate (`prism-protocol-sdk`):**
  - [x] Address finders for PDA derivation ✅
  - [x] Instruction builders for transaction construction ✅
  - [x] Client-side utilities ✅
- **Merkle Tree Crate (`prism-protocol-merkle`):**
  - [x] Off-chain merkle tree construction ✅
  - [x] Proof generation and verification utilities ✅
  - [x] Consistent hashing for vault assignment ✅
  - [x] Custom hasher with domain separation ✅
- **Testing Utilities (`prism-protocol-testing`):**
  - [x] Shared test fixtures and utilities ✅
  - [x] Mollusk SVM integration helpers ✅

### Off-Chain CLI (`apps/prism-protocol-cli`)

- **Status:** _Phase 0 & 1 Implemented, Phase 2+ In Progress_
- **Priority:** High - Core functionality complete, deployment features next

#### Planned CLI Features & Implementation Phases

**Phase 0: Fixture Generation (For Benchmarking) ✅ COMPLETED**

- **Purpose:** Generate large-scale test datasets for performance validation
- **Commands:**
  - `cargo run -p prism-protocol-cli -- generate-fixtures --count <N> --seed <SEED> [options]`
  - Support for deterministic pubkey generation (no real keypairs needed)
  - Configurable entitlement distributions (uniform, realistic, exponential)
  - CSV output format (campaign.csv and cohorts.csv)
  - Multi-cohort fixture generation with configurable cohort counts
- **Key Features:**
  - ✅ Deterministic generation for reproducible benchmarks
  - ✅ Memory-efficient for millions of claimants
  - ✅ Realistic distribution patterns for testing
  - ✅ Progress tracking for large datasets
  - ✅ Configurable cohort and entitlement ranges

**Phase 1: Core Campaign Generation ✅ COMPLETED**

- **Purpose:** Process campaign configs and generate all necessary data
- **Commands:**
  - `cargo run -p prism-protocol-cli -- compile-campaign --campaign-csv <file> --cohorts-csv <file> --mint <pubkey> --admin-keypair <file>`
- **Input:** Two CSV files (campaign claimants and cohort configuration)
- **Output:**
  - ✅ SQLite database with complete campaign structure
  - ✅ Vault count calculation and funding requirements
  - ✅ Claimant records with entitlements and vault assignments
  - ✅ Admin keypair validation and public key storage
  - ✅ Campaign fingerprint calculation from sorted cohort merkle roots
  - ✅ Individual cohort merkle roots generated and stored
  - ✅ Merkle proofs for all claimants generated and stored
  - ✅ Complete merkle tree integration with consistent hashing
  - ✅ Hex-encoded storage of all merkle data in database

**Phase 2: Transaction Building & Deployment ✅ COMPLETED**

- **Purpose:** Deploy complete campaigns on-chain (campaign + all cohorts)
- **Commands:**
  - `cargo run -p prism-protocol-cli -- deploy-campaign --campaign-db-in <campaign.db> --admin-keypair <admin.json> [--rpc-url <url>]`
  - `cargo run -p prism-protocol-cli -- campaign-status --campaign-fingerprint <fingerprint> [--rpc-url <url>]`
- **Features:**
  - ✅ Read complete campaign data from SQLite database (generated by compile-campaign)
  - ✅ Deploy campaign PDA and all cohort PDAs in sequence
  - ✅ Automatic transaction construction using SDK utilities
  - ✅ Progressive deployment status tracking and database updates
  - ✅ Transaction signature storage for campaign and cohort deployments
  - ✅ Vault creation and funding with token transfers from admin
  - ✅ Pre-flight checks for SOL and token balances
  - ✅ Comprehensive deployment verification
  - ✅ Default to localnet for development, configurable RPC endpoint
  - ✅ Enhanced progress reporting similar to `anchor deploy`

**Phase 3: Claiming Ecosystem Foundation 🚧 IN PROGRESS**

- **Purpose:** Build complete claiming infrastructure with clean separation between test fixtures and real campaigns
- **Strategic Approach:** Full ecosystem including enhanced fixtures, API server, and dApp support with unified CLI architecture
- **Key Architectural Decisions:**
  - **Clean Directory Separation:** 
    - `test-artifacts/fixtures/{slug}/` - Campaign source files with real keypairs
    - `test-artifacts/campaigns/` - Compiled test campaigns (API-servable)
    - `campaigns/` - Compiled production campaigns (API-servable)
  - **Campaign vs Compiled Campaign:** CSV files are "campaigns" (source), SQLite DBs are "compiled campaigns" (deployable/servable)
  - **Database as Single Source of Truth:** Created by compile, updated by deploy, served by API
  - **Unified CLI:** API server as `prism-protocol-cli serve-api` subcommand, one Docker container for all functionality
  - **API Server Simplicity:** Reads from single campaigns directory (`--campaigns-dir test-artifacts/campaigns/` or `--campaigns-dir campaigns/`)

- **Components:**
  1. **Enhanced Fixture Generator** (Week 1 - Foundation)
     - Default output: `test-artifacts/fixtures/{campaign-slug}/` (slugified campaign names)
     - Always generate real, random keypairs for all claimants (no more dummy pubkeys)
     - Backward compatible with existing interface
     - Clear separation from production campaigns
     - See: `docs/specs/ENHANCED_FIXTURE_GENERATOR_SPEC.md`
  
  2. **API Server** (`prism-protocol-cli serve-api`) (Week 2 - Core Infrastructure)
     - Subcommand of existing CLI for unified toolchain
     - Serves merkle proofs from compiled campaign databases only
     - Single directory interface: `--campaigns-dir` for clean separation
     - Portable and stateless (only needs compiled .db files)
     - Optional transaction building for dApps
     - Feature-flagged implementation for clean separation
     - See: `docs/specs/API_SERVER_SPEC.md`
  
  3. **CLI Claim Integration** (Week 3 - Testing)
     - `claim-tokens` command using API server for proof lookup
     - End-to-end testing with real HD wallet keypairs from fixtures
     - Multi-user concurrent claim testing
     - Integration between fixtures → compile → deploy → claim workflow
  
  4. **dApp Frontend** (Week 4-5 - User Interface)
     - Next.js/React with Solana wallet integration
     - Campaign discovery and claiming interface
     - Integration with API server for proofs and transaction building
     - Mobile-responsive design with progressive disclosure
     - See: `docs/specs/DAPP_FRONTEND_SPEC.md`

**Unified Docker Architecture:**
- Single Docker image for all CLI functionality
- Can run different commands in separate containers
- API server, deployment, and campaign management all from one binary
- Simplified deployment and development workflow

**Phase 4: Campaign Management & Production Readiness 📋 PLANNED**

- **Purpose:** Administrative operations, production deployment, and campaign creation tools
- **Strategic Components:**
  
  1. **Campaign Admin dApp** (New Strategic Component)
     - Web UI for campaign operators to define campaigns (replaces manual CSV creation)
     - Visual cohort configuration and claimant list management
     - Export to CLI-compatible formats
     - Campaign preview and validation
     - Integration with secrets management for secure admin operations

  2. **CLI Administrative Operations**
     - `cargo run -p prism-protocol-cli -- pause-campaign <fingerprint> --admin-keypair <admin.json>`
     - `cargo run -p prism-protocol-cli -- resume-campaign <fingerprint> --admin-keypair <admin.json>`
     - `cargo run -p prism-protocol-cli -- reclaim-tokens <fingerprint> <cohort-root> --admin-keypair <admin.json>`

  3. **Production Infrastructure**
     - Docker containerization for full stack
     - API rate limiting and security
     - Performance optimization for 100K+ claimants
     - Monitoring and alerting

**Phase 5: Advanced Features (Future)**

- **Purpose:** Enhanced functionality for complex use cases
- **Potential Commands:**
  - `prism-protocol-cli validate-campaign <config.yaml>` (dry-run validation)
  - `prism-protocol-cli estimate-costs <config.yaml>` (rent and transaction cost estimation)
  - `prism-protocol-cli export-proofs <fingerprint> --format <json|api>` (proof serving formats)
  - `prism-protocol-cli benchmark <config.yaml>` (performance testing)
- **Advanced Features:**
  - Jito bundle building for MEV protection
  - Claim status tracking and analytics
  - Horizontal scaling support
  - Campaign templates and batch operations

#### Core Functionality Checklist (Detailed)

- **Configuration Processing:**

  - [x] CSV campaign configuration parsing ✅
  - [x] Claimant list processing (CSV format) ✅
  - [x] Input validation and error handling ✅
  - [x] Cohort consistency validation ✅
  - [ ] Configuration schema documentation

- **Database & Storage:**

  - [x] SQLite database schema design ✅
  - [x] Campaign metadata storage ✅
  - [x] Cohort and claimant data storage ✅
  - [x] Vault funding requirements calculation ✅
  - [x] Admin keypair validation and public key storage ✅
  - [x] Progressive deployment status tracking ✅
  - [x] Transaction signature storage ✅

- **Merkle Tree Operations:**

  - [x] `ClaimLeaf` data generation (claimant, assigned_vault, entitlements) ✅
  - [x] Merkle tree generation for each cohort using `prism-protocol-merkle` ✅
  - [x] Consistent hashing for vault assignment ✅
  - [x] Individual proof generation for all claimants ✅

- **Campaign Fingerprint System:**

  - [x] Cohort merkle root collection and sorting ✅
  - [x] Deterministic `campaign_fingerprint` calculation ✅
  - [x] Fingerprint validation and collision detection ✅

- **On-Chain Deployment:**

  - [x] Campaign PDA deployment with transaction building ✅
  - [x] Cohort PDA deployment for all cohorts ✅
  - [x] Vault creation and funding with token transfers ✅
  - [x] Campaign activation after successful deployment ✅
  - [x] Pre-flight balance checks (SOL and tokens) ✅
  - [x] Progressive database updates during deployment ✅
  - [x] Comprehensive deployment verification ✅

- **Output Generation:**

  - [x] SQLite database with complete campaign structure ✅
  - [x] Vault funding requirements with exact amounts ✅
  - [x] Claimant records with entitlements ✅
  - [x] Merkle proofs and vault assignments ✅
  - [x] Campaign fingerprint and cohort merkle roots ✅
  - [x] Transaction signatures for deployment tracking ✅
  - [ ] Human-readable reports and summaries

- **Integration & Testing:**
  - [x] Comprehensive test suite with fixture generation ✅
  - [x] CSV parsing and validation tests ✅
  - [x] Database creation and population tests ✅
  - [x] CLI integration test automation with real command execution ✅
  - [x] Performance benchmarking test suite ✅
  - [x] Integration with `prism-protocol-merkle` for tree operations ✅
  - [x] Deterministic behavior validation and error handling tests ✅
  - [x] Integration with `prism-protocol-sdk` for transaction building ✅
  - [x] Performance benchmarking with large datasets (automated via make test-performance) ✅

#### Technical Implementation Notes

- **Dependencies:** Will use existing crates (`prism-protocol-sdk`, `prism-protocol-merkle`)
- **Configuration Format:** YAML for human readability, with JSON support
- **Performance Targets:** Handle millions of claimants efficiently
- **Error Handling:** Comprehensive validation with helpful error messages
- **Output Formats:** Multiple formats to support different integration needs

## 5. Testing Infrastructure & Coverage Analysis

### Current Test Coverage ✅

**Unit Tests (`cargo test`):**

- [x] Merkle tree generation and proof verification ✅
- [x] Address derivation functions ✅
- [x] Instruction builders ✅
- [x] Basic CLI argument parsing ✅

**CLI Integration Tests (`scripts/test-cli.sh`):**

- [x] Fixture generation with various distributions ✅
- [x] Campaign compilation and database creation ✅
- [x] Database schema validation ✅
- [x] Merkle tree storage and retrieval ✅

**Anchor Program Tests (`anchor test`):**

- [x] Campaign initialization ✅
- [x] Cohort initialization ✅
- [x] Vault creation ✅
- [x] Token claiming with merkle proofs ✅
- [x] Access control and authorization ✅

**End-to-End Tests (`scripts/test-e2e.sh`):** 🆕

- [x] Complete workflow: token creation → minting → deployment → verification ✅
- [x] Local validator setup and SPL token operations ✅
- [x] Campaign and cohort deployment ✅
- [x] Vault creation and funding (separated operations) ✅
- [x] Database tracking of deployment signatures ✅
- [x] Progressive deployment status updates ✅

### Enhanced Database Schema ✅

**Vault Lifecycle Tracking:**

- [x] `created_at` - timestamp when vault PDA was created on-chain ✅
- [x] `created_by_tx` - transaction signature for vault creation ✅
- [x] `funded_at` - timestamp when vault was funded with tokens ✅
- [x] `funded_by_tx` - transaction signature for vault funding ✅
- [x] Surgical database updates for each operation ✅

### Identified Testing Gaps ⚠️

**Critical: Claiming Ecosystem Gaps**

- [ ] **Enhanced Fixture Generator** - No campaign-organized directory structure
- [ ] **HD Wallet Generation** - Current fixtures use dummy pubkeys, not derivable keypairs
- [ ] **API Server** - No proof serving infrastructure exists
- [ ] **CLI Claim Command** - No `claim-tokens` command implemented
- [ ] **dApp Frontend** - No user interface for claiming

**Missing End-to-End Scenarios:**

- [ ] **Token claiming workflow** - No actual claim testing yet
- [ ] **Multi-user claim scenarios** - Testing concurrent claims with real keypairs
- [ ] **API server integration** - Testing proof serving and transaction building
- [ ] **Campaign activation/deactivation** - Testing state transitions
- [ ] **Error recovery scenarios** - Testing failed deployments and retries
- [ ] **Large-scale testing** - Testing with realistic token amounts and user counts

**Missing Integration Scenarios:**

- [ ] **Cross-cohort claiming** - Users claiming from multiple cohorts
- [ ] **Vault exhaustion** - Testing behavior when vaults run out of tokens
- [ ] **Invalid proof handling** - Testing malformed or incorrect proofs
- [ ] **Network failure recovery** - Testing deployment resilience
- [ ] **API server load testing** - Testing concurrent proof requests

**Performance & Scale Testing:**

- [ ] **Large merkle trees** - Testing with 100K+ claimants
- [ ] **HD wallet generation** - Performance testing for millions of keypairs
- [ ] **API server performance** - Response times with large campaign databases
- [ ] **Transaction batching** - Optimizing deployment transaction costs
- [ ] **Memory usage profiling** - Ensuring efficient resource usage

### Recommended Next Steps (Strategic Claiming Ecosystem)

1. **Phase 3 Foundation (Week 1)** - Enhanced fixture generator with HD wallets
2. **API Server Core (Week 2)** - Proof serving from campaign databases
3. **CLI Integration (Week 3)** - Claim command using API server
4. **dApp Frontend (Week 4-5)** - User interface for claiming
5. **Production Readiness (Week 6)** - Security, performance, monitoring

## 6. Key Design Decisions & Implementation Notes

- **✅ Campaign Fingerprint System:**
  - Campaigns are identified by a cryptographic fingerprint derived from constituent cohort merkle roots
  - Ensures immutability and verifiability of campaign definitions
- **✅ Merkle Tree Security:**
  - Domain separation using 0x00 prefix for leaves, 0x01 for internal nodes
  - Prevents second preimage attacks and ensures proof integrity
- **✅ Vault Assignment:**
  - Consistent hashing distributes claimants across multiple vaults
  - Reduces write contention while maintaining deterministic assignment
- **✅ Modular Architecture:**
  - Clean separation between on-chain program and off-chain utilities
  - Reusable SDK and testing components

## 7. Benchmarking Plan (using Mollusk SVM)

- **Objective:** Quantitatively validate performance, scalability, and resource consumption.
- **On-Chain Benchmarking Areas:**
  - [ ] **`claim_tokens_v0` Performance:**
    - CU consumption vs. proof length for various cohort sizes
    - Transaction size analysis
    - Maximum practical cohort size determination
  - [ ] **Account Sizes & Rent:**
    - Document rent costs for `CampaignV0`, `CohortV0`, `ClaimReceiptV0` PDAs
    - Compare costs across different vault configurations
  - [ ] **Initialization Instructions:**
    - CU consumption for each instruction type
    - Transaction size analysis
- **Off-Chain Benchmarking Areas:**
  - [ ] Merkle tree generation time for large claimant lists
  - [ ] Proof generation time and memory usage
  - [ ] Consistent hashing performance

## 8. Documentation Checklist

- [x] `PROJECT_PLAN.md`: Updated to reflect current implementation ✅
- [ ] `DESIGN_NOTES.md`: Update to match actual implementation
- [ ] `CAMPAIGN_SETUP_GUIDE.md`: Update for future CLI implementation
- [ ] `README.md`: Update with new crate structure information
- [ ] **API Documentation:** Document the SDK crate public interfaces

## 9. Future Milestones (Post-MVP)

- [ ] Complete CLI tool implementation
- [ ] Performance benchmarking and optimization
- [ ] Enhanced cohort versions with additional optimizations
- [ ] Client-side SDK (JavaScript/TypeScript) development
- [ ] Security audit preparation
- [ ] Advanced CLI features (campaign management, interactive modes)
- [ ] **Campaign Data Model Extraction** - Extract campaign data structures from CLI into reusable library
- [ ] **Campaign Admin dApp** - Visual campaign creation and management interface
- [ ] **Multi-signature Admin Support** - Enhanced security for campaign operations
- [ ] **Campaign Analytics Dashboard** - Real-time claiming metrics and insights

## 10. Current Status Summary

**✅ Completed:**

- Core on-chain program with all essential instructions
- Complete crate separation and modular architecture
- Comprehensive test suite with Mollusk SVM integration
- Merkle tree utilities with security best practices
- SDK for client-side transaction building
- **CLI Phase 0**: Fixture generation with deterministic test data
- **CLI Phase 1**: Complete campaign compilation with full merkle tree integration
  - CSV processing and database creation
  - Merkle tree generation with consistent hashing
  - Campaign fingerprint calculation from sorted cohort roots
  - Individual merkle proofs for all claimants
  - Hex-encoded storage of all merkle data
- **CLI Phase 2**: Complete on-chain deployment functionality
  - Campaign and cohort PDA deployment
  - Vault creation and funding with token transfers
  - Progressive database updates with transaction signatures
  - Pre-flight checks and comprehensive verification
- **Test Automation System**: Comprehensive CLI testing with real command execution
  - CLI integration tests with database validation
  - Performance benchmarking suite
  - Automated test orchestration via Makefile
  - Organized test artifact management
- **Secrets Management Infrastructure**: Team-based keypair management with encryption
- Admin keypair validation and proper public key storage
- Vault count calculation and funding requirements

**🚧 In Progress:**

- **End-to-End Test Suite**: Complete token creation → deployment → verification testing
- Final test gap closure for branch completion

**📋 Next Priorities:**

- Complete E2E test implementation
- Branch finalization and PR preparation
- Documentation updates for deployment features
